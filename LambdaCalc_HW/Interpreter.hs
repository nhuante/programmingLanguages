module Interpreter where

import AbsLambda -- provides the interface with the grammar and is automatically generated by bnfc
import ErrM
import PrintLambda
import Control.Monad.State

eval :: Exp -> Exp  
eval (App e1 e2) = case eval e1 of
    (Abs i e3) -> eval (subst i (eval e2) e3)
    e3 -> App e3 (eval e2)
eval (Abs i e) = Abs i (eval e)
eval x = x 

-- a quick and dirty way of getting fresh names. Rather inefficient for big terms...
freshAux :: Exp -> String
freshAux (Var (Id i)) = i ++ "0"
freshAux (App e1 e2) = freshAux e1 ++ freshAux e2
freshAux (Abs (Id i) e) = i ++ freshAux e

fresh = Id . freshAux 

-- (\id.e)s reduces to `subst id s e`
subst :: Id -> Exp -> Exp -> Exp
subst id s (Var id1) | id == id1 = s
                      | otherwise = Var id1
subst id s (App e1 e2) = App (subst id s e1) (subst id s e2)
subst id s (Abs id1 e1) = 
    let f = fresh (Abs id1 e1)
        e2 = subst id1 (Var f) e1 in 
        Abs f (subst id s e2)


